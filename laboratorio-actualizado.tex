\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{xcolor}
\usepackage{courier}
\usepackage{listings}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amsthm}

\pagestyle{fancy}
\fancyhf{}
\lhead{Laboratorio Frontend II}
\rhead{Desarrollo de Software I}
\cfoot{\thepage}

\titleformat{\section}{\large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{0.5em}{}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny,
  showstringspaces=false,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\color{purple},
  captionpos=b
}

\newtheorem{exercise}{Ejercicio}
\newtheorem{solution}{Soluci√≥n}

\title{\vspace{-2em}Laboratorio Frontend II\\\large Gu√≠a 07 - Aplicaci√≥n Avanzada de Gesti√≥n de Tareas}
\author{Curso: Desarrollo de Software I}
\date{Octubre 2025}

\begin{document}
\maketitle

\section*{Origen}
Implementaci√≥n avanzada de una aplicaci√≥n de gesti√≥n de tareas con React que incluye funcionalidades empresariales como sistema de memoria robusto, gesti√≥n de backups y edici√≥n en tiempo real.

\section{Objetivos}
Al finalizar esta sesi√≥n de laboratorio, el estudiante ser√° capaz de:
\begin{itemize}
  \item Implementar un sistema de gesti√≥n de tareas completo con React.
  \item Desarrollar un sistema robusto de persistencia de datos con localStorage.
  \item Crear un sistema de backup y recuperaci√≥n de datos.
  \item Implementar validaciones avanzadas y manejo de duplicados.
  \item Gestionar fechas de vencimiento con indicadores visuales.
  \item Aplicar edici√≥n en l√≠nea de tareas con controles intuitivos.
  \item Desarrollar un panel de administraci√≥n de memoria.
\end{itemize}

\section{Capacidades Avanzadas}
\begin{itemize}
  \item Arquitectura modular con separaci√≥n de responsabilidades.
  \item Sistema de memoria con validaci√≥n y sanitizaci√≥n de datos.
  \item Manejo de estados complejos con React Hooks.
  \item Implementaci√≥n de patrones de dise√±o (Singleton para gesti√≥n de memoria).
  \item Gesti√≥n avanzada de eventos y navegaci√≥n por teclado.
  \item Sistema de notificaciones y alertas contextual.
  \item Responsive design con CSS Grid y Flexbox.
\end{itemize}

\section{Requerimientos}
\begin{itemize}
  \item Node.js v16 o superior.
  \item React 18+ con Create React App.
  \item Navegador moderno con soporte para localStorage.
  \item Editor de c√≥digo (VS Code recomendado).
\end{itemize}

\section{Arquitectura de la Aplicaci√≥n}

\subsection{Estructura del Proyecto}
\begin{verbatim}
todo-app/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ manifest.json
‚îÇ   ‚îî‚îÄ‚îÄ favicon.ico
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ App.js              // Componente principal
‚îÇ   ‚îú‚îÄ‚îÄ App.css             // Estilos principales
‚îÇ   ‚îú‚îÄ‚îÄ TaskItem.js         // Componente de tarea individual
‚îÇ   ‚îú‚îÄ‚îÄ memory.js           // Sistema de gesti√≥n de memoria
‚îÇ   ‚îú‚îÄ‚îÄ index.js            // Punto de entrada
‚îÇ   ‚îî‚îÄ‚îÄ index.css           // Estilos globales
‚îî‚îÄ‚îÄ README.md
\end{verbatim}

\subsection{Funcionalidades Implementadas}
\begin{itemize}
  \item \textbf{Gesti√≥n de Tareas}: Crear, editar, eliminar con validaci√≥n de duplicados
  \item \textbf{Fechas de Vencimiento}: Asignaci√≥n opcional con indicadores visuales
  \item \textbf{Sistema de Memoria}: localStorage robusto con validaci√≥n y migraci√≥n
  \item \textbf{Backup Autom√°tico}: Creaci√≥n y restauraci√≥n de copias de seguridad
  \item \textbf{Edici√≥n en L√≠nea}: Modificaci√≥n directa con controles de guardar/cancelar
  \item \textbf{Indicadores de Estado}: Tareas vencidas, pr√≥ximas a vencer, completadas
  \item \textbf{Panel de Administraci√≥n}: Estad√≠sticas y gesti√≥n de memoria
\end{itemize}

\section{Implementaci√≥n T√©cnica}

\subsection{Componente Principal (App.js)}
\begin{lstlisting}[language=JavaScript,caption={Estructura principal de la aplicaci√≥n}]
import { useMemo, useState, useEffect } from "react";
import "./App.css";
import TaskItem from "./TaskItem";
import taskMemory from "./memory";

function App() {
  const [task, setTask] = useState("");
  const [dueDate, setDueDate] = useState("");
  const [tasks, setTasks] = useState([]);
  const [memoryStats, setMemoryStats] = useState(null);
  const [showMemoryInfo, setShowMemoryInfo] = useState(false);

  // Cargar tareas del sistema de memoria al iniciar
  useEffect(() => {
    try {
      const savedTasks = taskMemory.loadTasks();
      setTasks(savedTasks);
      console.log(`Cargadas ${savedTasks.length} tareas desde la memoria`);
    } catch (error) {
      console.error('Error cargando tareas:', error);
    }
  }, []);

  // Guardar tareas en el sistema de memoria cuando cambie el estado
  useEffect(() => {
    if (tasks.length > 0 || JSON.stringify(tasks) !== JSON.stringify([])) {
      const success = taskMemory.saveTasks(tasks);
      if (!success) {
        console.warn('No se pudieron guardar las tareas');
      }
    }
  }, [tasks]);

  // Actualizar estad√≠sticas de memoria peri√≥dicamente
  useEffect(() => {
    const updateStats = () => {
      setMemoryStats(taskMemory.getMemoryStats());
    };
    updateStats();
    const interval = setInterval(updateStats, 30000);
    return () => clearInterval(interval);
  }, []);

  const trimmed = task.trim();
  const isDuplicate = useMemo(
    () => tasks.some((t) => t.text.toLowerCase() === trimmed.toLowerCase()),
    [tasks, trimmed]
  );

  const addTask = () => {
    const t = trimmed;
    if (!t || isDuplicate) return;
    const id = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    setTasks((prev) => [
      ...prev,
      { 
        id, 
        text: t, 
        createdAt: new Date().toISOString(),
        dueDate: dueDate || null
      },
    ]);
    setTask("");
    setDueDate("");
  };

  const deleteTask = (id) => {
    setTasks((prev) => prev.filter((task) => task.id !== id));
  };

  const editTask = (id, newText, newDueDate) => {
    setTasks((prev) => 
      prev.map((task) => 
        task.id === id 
          ? { ...task, text: newText, dueDate: newDueDate || null }
          : task
      )
    );
  };

  return (
    <div className="app-container">
      <h1 className="app-title">
        Lista de Tareas
        <span className="task-counter">{tasks.length} tareas</span>
        <button className="memory-toggle" 
                onClick={() => setShowMemoryInfo(!showMemoryInfo)}>
          üíæ
        </button>
      </h1>
      {/* Panel de memoria y formulario de entrada */}
      <div className="input-section">
        <div className="input-row">
          <input
            placeholder="Escribe una tarea"
            value={task}
            onChange={(e) => setTask(e.target.value)}
          />
          <input
            type="date"
            value={dueDate}
            onChange={(e) => setDueDate(e.target.value)}
            className="date-input"
          />
          <button onClick={addTask} disabled={!trimmed || isDuplicate}>
            Agregar
          </button>
        </div>
      </div>
      {/* Lista de tareas */}
      <ul className="task-list">
        {tasks.map((t) => (
          <TaskItem
            key={t.id}
            id={t.id}
            text={t.text}
            createdAt={t.createdAt}
            dueDate={t.dueDate}
            onDelete={deleteTask}
            onEdit={editTask}
          />
        ))}
      </ul>
    </div>
  );
}

export default App;
\end{lstlisting}

\subsection{Sistema de Memoria (memory.js)}
\begin{lstlisting}[language=JavaScript,caption={Sistema robusto de gesti√≥n de memoria}]
const STORAGE_KEYS = {
  TASKS: 'todo-tasks',
  APP_VERSION: 'todo-app-version',
  LAST_BACKUP: 'todo-last-backup',
  USER_SETTINGS: 'todo-user-settings'
};

const CURRENT_VERSION = '1.0.0';
const MAX_BACKUP_ITEMS = 5;

class TaskMemory {
  constructor() {
    this.initializeStorage();
  }

  // Inicializar el sistema de almacenamiento
  initializeStorage() {
    try {
      if (!this.isLocalStorageAvailable()) {
        console.warn('localStorage no disponible, usando memoria temporal');
        this.fallbackStorage = new Map();
        return;
      }
      this.checkVersionAndMigrate();
      this.setupAutoBackup();
    } catch (error) {
      console.error('Error inicializando almacenamiento:', error);
      this.fallbackStorage = new Map();
    }
  }

  // Verificar disponibilidad de localStorage
  isLocalStorageAvailable() {
    try {
      const test = '__localStorage_test__';
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    } catch (e) {
      return false;
    }
  }

  // Cargar tareas desde la memoria
  loadTasks() {
    try {
      if (this.fallbackStorage) {
        return this.fallbackStorage.get(STORAGE_KEYS.TASKS) || [];
      }
      const tasksJson = localStorage.getItem(STORAGE_KEYS.TASKS);
      if (!tasksJson) return [];
      
      const tasks = JSON.parse(tasksJson);
      if (!Array.isArray(tasks)) {
        console.warn('Datos inv√°lidos, inicializando array vac√≠o');
        return [];
      }
      
      const validTasks = tasks.filter(task => this.validateTask(task))
                              .map(task => this.sanitizeTask(task));
      return validTasks;
    } catch (error) {
      console.error('Error cargando tareas:', error);
      this.createBackup('error-recovery');
      return [];
    }
  }

  // Guardar tareas en la memoria
  saveTasks(tasks) {
    try {
      if (!Array.isArray(tasks)) {
        throw new Error('Las tareas deben ser un array');
      }
      
      const validTasks = tasks.filter(task => this.validateTask(task))
                              .map(task => this.sanitizeTask(task));
      const tasksJson = JSON.stringify(validTasks);
      
      if (this.fallbackStorage) {
        this.fallbackStorage.set(STORAGE_KEYS.TASKS, validTasks);
        return true;
      }
      
      localStorage.setItem(STORAGE_KEYS.TASKS, tasksJson);
      localStorage.setItem('todo-last-saved', new Date().toISOString());
      return true;
    } catch (error) {
      console.error('Error guardando tareas:', error);
      return false;
    }
  }

  // Validar estructura de una tarea
  validateTask(task) {
    if (!task || typeof task !== 'object') return false;
    if (!task.id || typeof task.id !== 'string') return false;
    if (!task.text || typeof task.text !== 'string') return false;
    if (!task.createdAt || !this.isValidDate(task.createdAt)) return false;
    return true;
  }

  // Limpiar y sanitizar una tarea
  sanitizeTask(task) {
    return {
      id: String(task.id).trim(),
      text: String(task.text).trim(),
      createdAt: this.isValidDate(task.createdAt) ? 
        task.createdAt : new Date().toISOString(),
      dueDate: task.dueDate && this.isValidDate(task.dueDate) ? 
        task.dueDate : null
    };
  }

  // Crear backup de las tareas actuales
  createBackup(reason = 'manual') {
    try {
      if (this.fallbackStorage) return false;
      
      const currentTasks = this.loadTasks();
      const backup = {
        tasks: currentTasks,
        timestamp: new Date().toISOString(),
        reason: reason,
        version: CURRENT_VERSION
      };
      
      const backupKey = `todo-backup-${Date.now()}`;
      localStorage.setItem(backupKey, JSON.stringify(backup));
      localStorage.setItem(STORAGE_KEYS.LAST_BACKUP, backupKey);
      
      this.cleanOldBackups();
      return true;
    } catch (error) {
      console.error('Error creando backup:', error);
      return false;
    }
  }
}

// Crear instancia √∫nica (singleton)
const taskMemory = new TaskMemory();
export default taskMemory;
\end{lstlisting}

\subsection{Componente de Tarea (TaskItem.js)}
\begin{lstlisting}[language=JavaScript,caption={Componente avanzado de tarea individual}]
import { useState } from "react";

function TaskItem({ id, text, createdAt, dueDate, onDelete, onEdit }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(text);
  const [editDueDate, setEditDueDate] = useState(dueDate || "");

  // Formateo de fechas
  const createdDate = createdAt ? new Date(createdAt) : null;
  const formattedCreated = createdDate
    ? new Intl.DateTimeFormat(undefined, {
        dateStyle: "medium",
        timeStyle: "short",
      }).format(createdDate)
    : "";

  const dueDateObj = dueDate ? new Date(dueDate) : null;
  const formattedDueDate = dueDateObj
    ? new Intl.DateTimeFormat(undefined, {
        dateStyle: "medium",
      }).format(dueDateObj)
    : "";

  // Verificar si la tarea est√° vencida
  const isOverdue = dueDateObj && dueDateObj < new Date();
  const isDueSoon = dueDateObj && !isOverdue && 
    (dueDateObj.getTime() - new Date().getTime()) < (24 * 60 * 60 * 1000);

  const handleDelete = () => {
    if (window.confirm(`¬øEliminar la tarea "${text}"?`)) {
      onDelete(id);
    }
  };

  const handleEdit = () => {
    setIsEditing(true);
  };

  const handleSave = () => {
    if (editText.trim()) {
      onEdit(id, editText.trim(), editDueDate);
      setIsEditing(false);
    }
  };

  const handleCancel = () => {
    setEditText(text);
    setEditDueDate(dueDate || "");
    setIsEditing(false);
  };

  const handleKeyDown = (e) => {
    if (e.key === "Enter") {
      handleSave();
    } else if (e.key === "Escape") {
      handleCancel();
    }
  };

  // Modo de edici√≥n
  if (isEditing) {
    return (
      <li className="task-item editing">
        <div className="edit-form">
          <input
            type="text"
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onKeyDown={handleKeyDown}
            className="edit-input"
            autoFocus
          />
          <input
            type="date"
            value={editDueDate}
            onChange={(e) => setEditDueDate(e.target.value)}
            className="edit-date-input"
          />
          <div className="edit-buttons">
            <button onClick={handleSave} className="save-button"
                    title="Guardar cambios">‚úì</button>
            <button onClick={handleCancel} className="cancel-button"
                    title="Cancelar edici√≥n">‚úï</button>
          </div>
        </div>
      </li>
    );
  }

  // Vista normal con indicadores de estado
  return (
    <li className={`task-item ${isOverdue ? 'overdue' : ''} 
                   ${isDueSoon ? 'due-soon' : ''}`}>
      <div className="task-content">
        <span className="task-text">{text}</span>
        <div className="task-dates">
          {formattedCreated && (
            <time className="task-time created" dateTime={createdAt}>
              Creada: {formattedCreated}
            </time>
          )}
          {formattedDueDate && (
            <time className={`task-time due-date 
                            ${isOverdue ? 'overdue' : ''} 
                            ${isDueSoon ? 'due-soon' : ''}`} 
                  dateTime={dueDate}>
              {isOverdue ? '‚ö†Ô∏è Vencida: ' : 
               isDueSoon ? '‚è∞ Vence: ' : 
               'üìÖ Vence: '}{formattedDueDate}
            </time>
          )}
        </div>
      </div>
      <div className="task-actions">
        <button className="edit-button" onClick={handleEdit}
                title={`Editar tarea: ${text}`}>‚úèÔ∏è</button>
        <button className="delete-button" onClick={handleDelete}
                title={`Eliminar tarea: ${text}`}>‚úï</button>
      </div>
    </li>
  );
}

export default TaskItem;
\end{lstlisting}

\section{Caracter√≠sticas T√©cnicas Avanzadas}

\subsection{Sistema de Validaci√≥n}
\begin{itemize}
  \item \textbf{Validaci√≥n de duplicados}: Comparaci√≥n case-insensitive en tiempo real
  \item \textbf{Sanitizaci√≥n de datos}: Limpieza autom√°tica de inputs maliciosos
  \item \textbf{Validaci√≥n de fechas}: Verificaci√≥n de formatos ISO y fechas v√°lidas
  \item \textbf{Fallback de memoria}: Sistema de respaldo cuando localStorage no est√° disponible
\end{itemize}

\subsection{Gesti√≥n de Estado}
\begin{itemize}
  \item \textbf{useState}: Manejo de estado local de componentes
  \item \textbf{useEffect}: Efectos secundarios para persistencia y carga
  \item \textbf{useMemo}: Optimizaci√≥n de c√°lculos costosos (validaci√≥n de duplicados)
  \item \textbf{Patr√≥n Singleton}: Instancia √∫nica del sistema de memoria
\end{itemize}

\subsection{Experiencia de Usuario}
\begin{itemize}
  \item \textbf{Navegaci√≥n por teclado}: Enter para guardar, Escape para cancelar
  \item \textbf{Confirmaciones}: Di√°logos de confirmaci√≥n para acciones destructivas
  \item \textbf{Retroalimentaci√≥n visual}: Estados de carga, error y √©xito
  \item \textbf{Responsive design}: Adaptaci√≥n a diferentes tama√±os de pantalla
\end{itemize}

\section{Sistema de Estilos CSS}

\subsection{Arquitectura CSS}
\begin{lstlisting}[language=CSS,caption={Estilos responsivos y accesibles}]
/* Contenedor principal */
.app-container {
  max-width: 600px;
  margin: 40px auto;
  padding: 1.5rem 2rem 2.5rem;
  border: 1px solid #ddd;
  border-radius: 12px;
  background: #fff;
  box-shadow: 0 4px 16px rgba(0,0,0,0.06);
}

/* T√≠tulo principal con contador y bot√≥n de memoria */
.app-title {
  text-align: center;
  margin-top: 0;
  font-size: 1.8rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  flex-wrap: wrap;
}

.task-counter {
  display: inline-block;
  margin-left: 10px;
  font-size: 0.9rem;
  color: #555;
  background: #f2f6fb;
  padding: 0.15rem 0.5rem;
  border-radius: 999px;
  vertical-align: middle;
}

.memory-toggle {
  background: #6c757d;
  color: white;
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 1.2rem;
  cursor: pointer;
}

/* Panel de informaci√≥n de memoria */
.memory-panel {
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1.5rem;
}

.memory-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 0.5rem;
  margin-bottom: 1rem;
}

/* Formulario de entrada */
.input-section {
  margin-bottom: 1.5rem;
}

.input-row {
  display: flex;
  gap: 8px;
  margin-bottom: 1rem;
}

input[type="text"] {
  flex: 2;
}

.date-input {
  flex: 1;
  min-width: 140px;
}

/* Items de tarea */
.task-item {
  padding: 0.75rem;
  border: 1px solid #e3e3e3;
  border-radius: 8px;
  margin-bottom: 8px;
  background: #fafafa;
  font-size: 0.95rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  transition: all 0.2s ease;
}

.task-item.overdue {
  border-color: #dc3545;
  background: #fdf2f2;
}

.task-item.due-soon {
  border-color: #ff9800;
  background: #fff8e1;
}

.task-item.editing {
  padding: 1rem;
  background: #f0f7ff;
  border-color: #1976d2;
}

/* Contenido de tarea */
.task-content {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  flex: 1;
}

.task-text {
  font-weight: 500;
  margin-right: 12px;
}

.task-dates {
  display: flex;
  flex-direction: column;
  gap: 0.2rem;
}

.task-time {
  color: #6b7280;
  font-size: 0.75rem;
}

.task-time.created {
  color: #9ca3af;
}

.task-time.due-date {
  font-weight: 500;
}

.task-time.due-date.overdue {
  color: #dc3545;
}

.task-time.due-date.due-soon {
  color: #ff9800;
}

/* Acciones de tarea */
.task-actions {
  display: flex;
  gap: 4px;
  margin-left: 8px;
}

.edit-button {
  background: #4caf50;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  font-size: 0.9rem;
  cursor: pointer;
  min-width: 32px;
  height: 32px;
}

.edit-button:hover {
  background: #45a049;
}

.delete-button {
  background: #dc3545;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  font-size: 0.9rem;
  cursor: pointer;
  min-width: 32px;
  height: 32px;
}

.delete-button:hover {
  background: #c82333;
}

/* Formulario de edici√≥n */
.edit-form {
  display: flex;
  gap: 8px;
  align-items: center;
  width: 100%;
}

.edit-input {
  flex: 2;
  padding: 0.5rem;
  font-size: 0.9rem;
}

.edit-date-input {
  flex: 1;
  padding: 0.5rem;
  font-size: 0.9rem;
  min-width: 120px;
}

.save-button {
  background: #4caf50;
  color: white;
  padding: 0.4rem 0.6rem;
  min-width: 32px;
  height: 32px;
}

.cancel-button {
  background: #6c757d;
  color: white;
  padding: 0.4rem 0.6rem;
  min-width: 32px;
  height: 32px;
}
\end{lstlisting}

\section{Actividades Avanzadas Implementadas}

\begin{enumerate}
  \item \textbf{Sistema de Backup Autom√°tico}
  \begin{itemize}
    \item Backup autom√°tico cada hora si hay cambios
    \item M√°ximo 5 backups simult√°neos
    \item Restauraci√≥n selectiva por fecha y motivo
  \end{itemize}

  \item \textbf{Gesti√≥n de Memoria Inteligente}
  \begin{itemize}
    \item Verificaci√≥n de espacio disponible
    \item Limpieza autom√°tica de datos antiguos
    \item Migraci√≥n de versiones autom√°tica
  \end{itemize}

  \item \textbf{Indicadores Visuales Contextuales}
  \begin{itemize}
    \item ‚ö†Ô∏è Tareas vencidas (rojo)
    \item ‚è∞ Tareas pr√≥ximas a vencer (naranja)
    \item üìÖ Fechas normales (gris)
  \end{itemize}

  \item \textbf{Panel de Administraci√≥n}
  \begin{itemize}
    \item Estad√≠sticas de uso de memoria
    \item Gesti√≥n manual de backups
    \item Limpieza total de datos con confirmaci√≥n
  \end{itemize}
\end{enumerate}

\section{Testing y Calidad}

\subsection{Pruebas Incluidas}
\begin{lstlisting}[language=JavaScript,caption={Ejemplo de test unitario}]
test("puede agregar una tarea", () => {
  render(<App />);
  const input = screen.getByPlaceholderText(/escribe una tarea/i);
  const button = screen.getByRole("button", { name: /agregar/i });
  
  expect(button).toBeDisabled();
  fireEvent.change(input, { target: { value: "Primera tarea" } });
  expect(button).not.toBeDisabled();
  
  fireEvent.click(button);
  expect(screen.getByText("Primera tarea")).toBeInTheDocument();
});
\end{lstlisting}

\subsection{Manejo de Errores}
\begin{itemize}
  \item Try-catch en todas las operaciones de localStorage
  \item Validaci√≥n de entrada en tiempo real
  \item Mensajes de error contextual y accesibles
  \item Recuperaci√≥n autom√°tica de errores con backups
\end{itemize}

\section{Instalaci√≥n y Ejecuci√≥n}

\subsection{Comandos de Desarrollo}
\begin{verbatim}
# Instalar dependencias
npm install

# Iniciar servidor de desarrollo
npm start

# Ejecutar tests
npm test

# Construir para producci√≥n
npm run build
\end{verbatim}

\subsection{Scripts Disponibles}
\begin{itemize}
  \item \texttt{npm start}: Servidor de desarrollo en \url{http://localhost:3000}
  \item \texttt{npm test}: Suite de tests con watching autom√°tico
  \item \texttt{npm run build}: Compilaci√≥n optimizada para producci√≥n
  \item \texttt{npm run eject}: Exposici√≥n de configuraci√≥n (no reversible)
\end{itemize}

\section{Referencias y Recursos}

\begin{itemize}
  \item \textbf{Documentaci√≥n React}: \url{https://react.dev/learn}
  \item \textbf{React Hooks}: \url{https://react.dev/reference/react}
  \item \textbf{Testing Library}: \url{https://testing-library.com/docs/react-testing-library/intro/}
  \item \textbf{Web Storage API}: \url{https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API}
  \item \textbf{CSS Grid Guide}: \url{https://css-tricks.com/snippets/css/complete-guide-grid/}
\end{itemize}

\newpage

\begin{exercise}
\textbf{Ejercicio 1: Implementaci√≥n del Sistema de Memoria Robusto}

Desarrollar un sistema de gesti√≥n de memoria que incluya:
\begin{itemize}
  \item Validaci√≥n autom√°tica de datos
  \item Sistema de backup y recuperaci√≥n
  \item Migraci√≥n de versiones
  \item Fallback para navegadores sin localStorage
\end{itemize}
\end{exercise}

\begin{solution}
La implementaci√≥n propuesta incluye:

\begin{enumerate}
  \item \textbf{Clase TaskMemory}: Singleton para gesti√≥n centralizada
  \item \textbf{Validaci√≥n}: Verificaci√≥n de estructura y tipos de datos
  \item \textbf{Sanitizaci√≥n}: Limpieza autom√°tica de datos de entrada
  \item \textbf{Backup autom√°tico}: Cada hora si hay cambios detectados
  \item \textbf{Recuperaci√≥n}: Sistema de restauraci√≥n selectiva
\end{enumerate}

Resultado: Sistema robusto y escalable que garantiza la integridad de los datos.
\[
\boxed{\text{Sistema de memoria empresarial implementado exitosamente}}
\]
\end{solution}

\begin{exercise}
\textbf{Ejercicio 2: Implementaci√≥n de Edici√≥n en L√≠nea}

Crear un sistema de edici√≥n que permita:
\begin{itemize}
  \item Edici√≥n directa en la interfaz
  \item Validaci√≥n en tiempo real
  \item Controles de guardar/cancelar
  \item Navegaci√≥n por teclado
\end{itemize}
\end{exercise}

\begin{solution}
Implementaci√≥n lograda mediante:

\begin{enumerate}
  \item \textbf{Estado local}: useState para modo de edici√≥n
  \item \textbf{Formulario inline}: Conversi√≥n de vista a edici√≥n
  \item \textbf{Eventos de teclado}: Enter/Escape para control r√°pido
  \item \textbf{Validaci√≥n}: Verificaci√≥n antes de guardar cambios
\end{enumerate}

Resultado: Experiencia de usuario fluida y intuitiva.
\[
\boxed{\text{Sistema de edici√≥n inline completamente funcional}}
\]
\end{solution}

\end{document}